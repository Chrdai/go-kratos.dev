<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://go-kratos.dev/en/blog</id>
    <title>Kratos Blog</title>
    <updated>2021-07-14T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://go-kratos.dev/en/blog"/>
    <subtitle>Kratos Blog</subtitle>
    <icon>https://go-kratos.dev/en/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[Go工程化 - 依赖注入]]></title>
        <id>go-project-wire</id>
        <link href="https://go-kratos.dev/en/blog/go-project-wire"/>
        <updated>2021-07-14T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[wire乍看起来比较违反直觉，导致很多同学不理解为什么要用或不清楚如何用（也包括曾经的我），本文来帮助大家理解wire的使用。]]></summary>
        <content type="html"><![CDATA[<p>我们在微服务框架<a href="https://github.com/go-kratos/kratos">kratos v2</a>的默认项目模板中<a href="https://github.com/go-kratos/kratos-layout">kratos-layout</a>使用了<a href="https://github.com/google/wire">google/wire</a>进行依赖注入，也建议开发者在维护项目时使用该工具。</p><p>wire 乍看起来比较违反直觉，导致很多同学不理解为什么要用或不清楚如何用（也包括曾经的我），本文来帮助大家理解 wire 的使用。</p><h2>What</h2><p><a href="https://github.com/google/wire">wire</a>是由 google 开源的一个供 Go 语言使用的依赖注入代码生成工具。它能够根据你的代码，生成相应的依赖注入 go 代码。</p><p>而与其它依靠反射实现的依赖注入工具不同的是，wire 能在编译期（准确地说是代码生成时）如果依赖注入有问题，在代码生成时即可报出来，不会拖到运行时才报，更便于 debug。</p><h2>Why</h2><h3>理解依赖注入</h3><p>什么是依赖注入？为什么要依赖注入？
<del>依赖注入就是 Java 遗毒</del>（不是）</p><p><a href="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">依赖注入</a> (Dependency Injection，缩写为 DI)，可以理解为一种代码的构造模式（就是写法），按照这样的方式来写，能够让你的代码更加容易维护。</p><p>对于很多软件设计模式和架构的理念，我们都无法理解他们要绕好大一圈做复杂的体操、用奇怪的方式进行实现的意义。他们通常都只是丢出来一段样例，说这样写就很好很优雅，由于省略掉了这种模式是如何发展出来的推导过程，我们只看到了结果，导致理解起来很困难。那么接下来我们来尝试推导还原一下整个过程，看看代码是如何和为什么演进到依赖注入模式的，以便能够更好理解使用依赖注入的意义。</p><h4>依赖是什么？</h4><p>这里的依赖是个名词，不是指软件包的依赖（比如那坨塞在 node_modules 里面的东西），而是指软件中某一个模块（对象/实例）所依赖的其它外部模块（对象/实例）。</p><h4>注入到哪里？</h4><p>被依赖的模块，在创建模块时，被注入到（即当作参数传入）模块的里面。</p><h4>不 DI 是啥样？DI 了又样子？</h4><p>下面用 go 伪代码来做例子，领会精神即可。</p><p>假设个场景，你在打工搞一个 web 应用，它有一个简单接口。最开始的项目代码可能长这个样子：</p><pre><code class="language-go"># 下面为伪代码，忽略了很多与主题无关的细节

type App struct {
}

# 假设这个方法将会匹配并处理 GET /biu/&lt;id&gt; 这样的请求
func (a *App) GetData(id string) string {
    # todo: write your data query
    return &quot;some data&quot;
}

func NewApp() *App {
    return &amp;App{}
}

app := App()
app.Run()
</code></pre><p>你要做的是接一个 mysql，从里面把数据按照 id 查出来，返回。
要连 mysql 的话，假设我们已经有了个<code>NewMySQLClient</code>的方法返回 client 给你，初始化时传个地址进去就能拿到数据库连接，并假设它有个<code>Exec</code>的方法给你执行参数。</p><h5>不用 DI，通过全局变量传递依赖实例</h5><p>一种写法是，在外面全局初始化好 client，然后 App 直接拿来调用。</p><pre><code class="language-go">
var mysqlUrl = &quot;mysql://blabla&quot;
var db = NewMySQLClient(mysqlUrl)


type App struct {

}

func (a *App) GetData(id string) string {
    data := db.Exec(&quot;select data from biu where id = ? limit 1&quot;, id)
    return data
}


func NewApp() *App {
    return &amp;App{}
}
func main() {
    app := App()
    app.Run()
}
</code></pre><p>这就是没用依赖注入，app 依赖了全局变量 db，这是比较糟糕的一种做法。db 这个对象游离在全局作用域，暴露给包下的其他模块，比较危险。（设想如果这个包里其他代码在运行时悄悄把你的这个 db 变量替换掉会发生啥）</p><h5>不用 DI，在 App 的初始化方法里创建依赖实例</h5><p>另一种方式是这样的：</p><pre><code class="language-go">type App struct {
    db *MySQLClient
}

func (a *App) GetData(id string) string {
    data := a.db.Exec(&quot;select data from biu where id = ? limit 1&quot;, id)
    return data
}


func NewApp() *App {
    return &amp;App{db: NewMySQLClient(mysqlUrl)}
}
func main() {
    app := NewApp(&quot;mysql://blabla&quot;)
    app.Run()
}
</code></pre><p>这种方法稍微好一些，db 被塞到 app 里面了，不会有 app 之外的无关代码碰它，比较安全，但这依然不是依赖注入，而是在内部创建了依赖，接下来你会看到它带来的问题。</p><h5>老板：我们的数据要换个地方存 （需要变更实现）</h5><p>你的老板不知道从哪听说——Redis 贼特么快，要不我们的数据改从 Redis 里读吧。这个时候你的内心有点崩溃，但毕竟要恰饭的，就硬着头皮改上面的代码。</p><pre><code class="language-go">type App struct {
    ds *RedisClient
}

func (a *App) GetData(id string) string {
    data := a.ds.Do(&quot;GET&quot;, &quot;biu_&quot;+id)
    return data
}


func NewApp() *App {
    return &amp;App{ds: NewRedisClient(redisAddr)}
}

func main() {
    app := NewApp(&quot;redis://ooo&quot;)
    app.Run()
}
</code></pre><p>上面基本进行了 3 处修改：</p><ol><li>App 初始化方法里改成了初始化 RedisClient</li><li>get_data 里取数据时改用 run 方法，并且查询语句也换了</li><li>App 实例化时传入的参数改成了 redis 地址</li></ol><h5>老板：要不，我们再换个地方存？/我们要加测试，需要 Mock</h5><p>老板的思路总是很广的，又过了两天他又想换成 Postgres 存了；或者让你们给 App 写点测试代码，只测接口里面的逻辑，通常我们不太愿意在旁边再起一个数据库，那么就需要 mock 掉数据源这块东西，让它直接返回数据给请求的 handler 用，来进行针对性的测试。</p><p>这种情况怎么办？再改里面的代码？这不科学。</p><h5>面向接口编程</h5><p>一个很重要的思路就是要<strong>面向接口(interface)编程</strong>，而不是面向具体实现编程。</p><p>什么叫面向具体实现编程呢？比如上述的例子里改动的部分：调 mysqlclient 的 exec_sql 执行一条 sql，被改成了：调 redisclient 的 do 执行一句 get 指令。由于每种 client 的接口设计不同，每换一个实现，就得改一遍。</p><p>而面向接口编程的思路，则完全不同。我们不要听老板想用啥就马上写代码。首先就得预料到，这个数据源的实现很有可能被更换，因此在一开始就应该做好准备（设计）。</p><h6>设计接口</h6><p>Python 里面有个概念叫鸭子类型(duck-typing)，就是如果你叫起来像鸭子，走路像鸭子，游泳像鸭子，那么你就是一只鸭子。这里的叫、走路、游泳就是我们约定的鸭子接口，而你如果完整实现了这些接口，我们可以像对待一个鸭子一样对待你。</p><p>在我们上面的例子中，不论是 Mysql 实现还是 Redis 实现，他们都有个共同的功能：用一个 id，查一个数据出来，那么这就是共同的接口。</p><p>我们可以约定一个叫 DataSource 的接口，它必须有一个方法叫 GetById，功能是要接收一个 id，返回一个字符串</p><pre><code class="language-go">type DataSource interface {
    GetById(id string) string
}
</code></pre><p>然后我们就可以把各个数据源分别进行封装，按照这个 interface 定义实现接口，这样我们的 App 里处理请求的部分就可以稳定地调用 GetById 这个方法，而底层数据实现只要实现了 DataSource 这个 interface 就能花式替换，不用改 App 内部的代码了。</p><pre><code class="language-go">// 封装个redis
type redis struct {
    r *RedisClient
}

func NewRedis(addr string) *redis {
    return &amp;redis{r: NewRedisClient(addr)}
}

func (r *redis) GetById(id string) string {
    return r.r.Do(&quot;GET&quot;, &quot;biu_&quot;+id)
}


// 再封装个mysql
type mysql struct {
    m *MySQLClient
}

func NewMySQL(addr string) *redis {
    return &amp;mysql{m: NewMySQLClient(addr)}
}

func (m *mysql) GetById(id string) string {
    return r.m.Exec(&quot;select data from biu where id = ? limit 1&quot;, id)
}


type App struct {
    ds DataSource
}

func NewApp(addr string) *App {
    //需要用Mysql的时候
    return &amp;App{ds: NewMySQLClient(addr)}

    //需要用Redis的时候
    return &amp;App{ds: NewRedisClient(addr)}
}

</code></pre><p>由于两种数据源都实现了 DataSource 接口，因此可以直接创建一个塞到 App 里面了，想用哪个用哪个，看着还不错？</p><h5>等一等，好像少了些什么</h5><p>addr 作为参数，是不是有点简单？通常初始化一个数据库连接，可能有一堆参数，配在一个 yaml 文件里，需要解析到一个 struct 里面，然后再传给对应的 New 方法。</p><p>配置文件可能是这样的：</p><pre><code class="language-yaml">redis:
    addr: 127.0.0.1:6379
    read_timeout: 0.2s
    write_timeout: 0.2s
</code></pre><p>解析结构体是这样的：</p><pre><code class="language-go">type RedisConfig struct {
    Network      string             `json:&quot;network,omitempty&quot;`
    Addr         string             `json:&quot;addr,omitempty&quot;`
    ReadTimeout  *duration.Duration `json:&quot;read_timeout,omitempty&quot;`
    WriteTimeout *duration.Duration `json:&quot;write_timeout,omitempty&quot;`
}
</code></pre><p>结果你的<code>NewApp</code>方法可能就变成了这个德性：</p><pre><code class="language-go">func NewApp() *App {
    var conf *RedisConfig
    yamlFile, err := ioutil.ReadFile(&quot;redis_conf.yaml&quot;)
    if err != nil {
        panic(err)
    }
    err = yaml.Unmarshal(yamlFile, &amp;conf)
    if err != nil {
        panic(err)
    }
    return &amp;App{ds: NewRedisClient(conf)}
}
</code></pre><p>NewApp 说，停停，你们年轻人不讲武德，我的责任就是创建一个 App 实例，我只需要一个 DataSource 注册进去，至于这个 DataSource 是怎么来的我不想管，这么一坨处理 conf 的代码凭什么要放在我这里，我也不想关心你这配置文件是通过网络请求拿来的还是从本地磁盘读的，我只想把 App 组装好扔出去直接下班。</p><h5>依赖注入终于可以登场了</h5><p>还记得前面是怎么说依赖注入的吗？被依赖的模块，在创建模块时，被注入到（即当作参数传入）初始化函数里面。通过这种模式，正好可以让 NewApp 早点下班。我们在外面初始化好 NewRedis 或者 NewMysql，得到的 DataSource 直接扔给 NewApp。</p><p>也就是这样</p><pre><code class="language-go">func NewApp(ds DataSource) *App {
    return &amp;App{ds: ds}
}
</code></pre><p>那坨读配置文件初始化 redis 的代码扔到初始化 DataSource 的方法里去</p><pre><code class="language-go">func NewRedis() DataSource {
    var conf *RedisConfig
    yamlFile, err := ioutil.ReadFile(&quot;redis_conf.yaml&quot;)
    if err != nil {
        panic(err)
    }
    err = yaml.Unmarshal(yamlFile, &amp;conf)
    if err != nil {
        panic(err)
    }
    return &amp;redis{r: NewRedisClient(conf)}
}
</code></pre><p>更进一步，NewRedis 这个方法甚至也不需要关心文件是怎么读的，它的责任只是通过 conf 初始化一个 DataSource 出来，因此你可以继续把读 config 的代码往外抽，把 NewRedis 做成接收一个 conf，输出一个 DataSource</p><pre><code class="language-go">func GetRedisConf() *RedisConfig
func NewRedis(conf *RedisConfig) DataSource
</code></pre><p>因为之前整个组装过程是散放在 main 函数下面的，我们把它抽出来搞成一个独立的 initApp 方法。最后你的 App 初始化逻辑就变成了这样</p><pre><code class="language-go">func initApp() *App {
    c := GetRedisConf()
    r := NewRedis(c)
    app := NewApp(r)
    return app
}

func main() {
    app := initApp()
    app.Run()
}
</code></pre><p>然后你可以通过实现 DataSource 的接口，更换前面的读取配置文件的方法，和更换创建 DataSource 的方法，来任意修改你的底层实现（读配置文件的实现，和用哪种 DataSource 来查数据），而不用每次都改一大堆代码。这使得你的代码层次划分得更加清楚，更容易维护了。</p><p>这就是依赖注入。</p><h5>手工依赖注入的问题</h5><p>上文这一坨代码，把各个实例初始化好，再按照各个初始化方法的需求塞进去，最终构造出 app 的这坨代码，就是注入依赖的过程。</p><pre><code class="language-go">c := GetRedisConf()
r := NewRedis(c)
app := NewApp(r)
</code></pre><p>目前只有一个 DataSource，这样手写注入过程还可以，一旦你要维护的东西多了，比如你的 NewApp 是这样的<code>NewApp(r *Redis, es *ES, us *UserSerivce, db *MySQL) *App</code>然后其中 UserService 是这样的<code>UserService(pg *Postgres, mm *Memcached)</code>，这样形成了多层次的一堆依赖需要注入，徒手去写非常麻烦。</p><p>而这部分，就是 wire 这样的依赖注入工具能够起作用的地方了——他的功能只是通过生成代码<strong>帮你注入依赖</strong>，而实际的依赖实例需要你自己创建（初始化）。</p><h2>How</h2><p>wire 的主要问题是，<del>看文档学不会</del>。反正我最初看完文档之后是一头雾水——这是啥，这要干啥？但通过我们刚才的推导过程，应该大概理解了为什么要用依赖注入，以及 wire 在这其中起到什么作用——通过生成代码<strong>帮你注入依赖</strong>，而实际的依赖实例需要你自己创建（初始化）。</p><p>接下来就比较清楚了。</p><p>首先要实现一个<code>wire.go</code>的文件，里面定义好 Injector。</p><pre><code>// +build wireinject

func initApp() (*App) {
    panic(wire.Build(GetRedisConf, NewRedis, SomeProviderSet, NewApp))
}
</code></pre><p>然后分别实现好 Provider。</p><p>执行<code>wire</code>命令后
他会扫描整个项目，并帮你生成一个<code>wire_gen.go</code>文件，如果你有什么没有实现好，它会报错出来。</p><p><del>你学会了吗？</del></p><h3>重新理解</h3><p>等一等，先别放弃治疗，让我们用<del>神奇的中文编程</del>来解释一下要怎么做。</p><h4>谁参与编译？</h4><p>上面那个<code>initApp</code>方法，官方文档叫它 Injector，由于文件里首行<code>// +build wireinject</code>这句注释，这个 wire.go 文件只会由 wire 读取，在 go 编译器在编译代码时不会去管它，实际会读的是生成的 wire_gen.go 文件。</p><p>而 Provider 就是你代码的一部分，肯定会参与到编译过程。</p><h4>Injector 是什么鬼东西？</h4><p>Injector 就是你最终想要的结果——最终的 App 对象的初始化函数，也就是前面那个例子里的<code>initApp</code>方法。</p><p>把它理解为你去吃金拱门，进门看到点餐机，噼里啪啦点了一堆，最后打出一张单子。</p><pre><code class="language-go">// +build wireinject

func 来一袋垃圾食品() 一袋垃圾食品 {
    panic(wire.Build(来一份巨无霸套餐, 来一份双层鳕鱼堡套餐, 来一盒麦乐鸡, 垃圾食品打包))
}
</code></pre><p>这就是你点的单子，它不参与编译，实际参与编译的代码是由 wire 帮你生成的。</p><h4>Provider 是什么鬼东西？</h4><p>Provider 就是创建各个依赖的方法，比如前面例子里的 NewRedis 和 NewApp 等。</p><p>你可以理解为，这些是金拱门的服务员和后厨要干的事情：
金拱门后厨需要提供这些食品的制作服务——实现这些实例初始化方法。</p><pre><code class="language-go">func 来一盒麦乐鸡() 一盒麦乐鸡 {}
func 垃圾食品打包(一份巨无霸套餐, 一份双层鳕鱼堡套餐, 一盒麦乐鸡) 一袋垃圾食品 {}
</code></pre><p>wire 里面还有个 ProviderSet 的概念，就是把一组 Provider 打包，因为通常你点单的时候很懒，不想这样点你的巨无霸套餐：我要一杯可乐，一包薯条，一个巨无霸汉堡；你想直接戳一下就好了，来一份巨无霸套餐。这个套餐就是 ProviderSet，一组约定好的配方，不然你的点单列表（injector 里的 Build）就会变得超级长，这样你很麻烦，服务员看着也很累。</p><p>用其中一个套餐举例</p><pre><code class="language-go">// 先定义套餐内容
var 巨无霸套餐 = wire.NewSet(来一杯可乐，来一包薯条，来一个巨无霸汉堡)

// 然后实现各个食品的做法
func 来一杯可乐() 一杯可乐 {}
func 来一包薯条() 一包薯条 {}
func 来一个巨无霸汉堡() 一个巨无霸汉堡 {}
</code></pre><h4>wire 工具做了啥？</h4><p>重要的事情说三遍，通过生成代码<strong>帮你注入依赖</strong>。</p><p>在金拱门的例子里就是，wire 就是个服务员，它按照你的订单，去叫做相应的同事把各个食物/套餐做好，然后最终按需求打包给你。这个中间协调构建的过程，就是注入依赖。</p><p>这样的好处就是，
对于金拱门，假设他们突然换可乐供应商了，直接把<code>来一杯可乐</code>替换掉就行，返回一种新的可乐，而对于顾客不需要有啥改动。
对于顾客来说，点单内容可以变换，比如我今天不想要麦乐鸡了，或者想加点别的，只要改动我的点单(只要金拱门能做得出来)，然后通过 wire 重新去生成即可，不需要关注这个服务员是如何去做这个订单的。</p><p>现在你应该大概理解 wire 的用处和好处了。</p><h4>总结</h4><p>让我们从金拱门回来，重新总结一下用 wire 做依赖注入的过程。</p><h5>1. 定义 Injector</h5><p>创建<code>wire.go</code>文件，定义下你最终想用的实例初始化函数例如<code>initApp</code>（即 Injector），定好它返回的东西<code>*App</code>，在方法里用<code>panic(wire.Build(NewRedis, SomeProviderSet, NewApp))</code>罗列出它依赖哪些实例的初始化方法（即 Provider）/或者哪些组初始化方法（ProviderSet）</p><h5>2. 定义 ProviderSet（如果有的话）</h5><p>ProviderSet 就是一组初始化函数，是为了少写一些代码，能够更清晰的组织各个模块的依赖才出现的。也可以不用，但 Injector 里面的东西就需要写一堆。
像这样 <code>var SomeProviderSet = wire.NewSet(NewES,NewDB)</code>定义 ProviderSet 里面包含哪些 Provider</p><h5>3. 实现各个 Provider</h5><p>Provider 就是初始化方法，你需要自己实现，比如 NewApp，NewRedis，NewMySQL，GetConfig 等，注意他们们各自的输入输出</p><h5>4. 生成代码</h5><p>执行 wire 命令生成代码，工具会扫描你的代码，依照你的 Injector 定义来组织各个 Provider 的执行顺序，并自动按照 Provider 们的类型需求来按照顺序执行和安排参数传递，如果有哪些 Provider 的要求没有满足，会在终端报出来，持续修复执行 wire，直到成功生成<code>wire_gen.go</code>文件。接下来就可以正常使用<code>initApp</code>来写你后续的代码了。</p><p>如果需要替换实现，对 Injector 进行相应的修改，实现必须的 Provider，重新生成即可。</p><p>它生成的代码其实就是类似我们之前需要手写的这个</p><pre><code>func initApp() *App {  // injector
    c := GetRedisConf() // provider
    r := NewRedis(c)  // provider
    app := NewApp(r) // provider
    return app
}
</code></pre><p>由于我们的例子比较简单，通过 wire 生成体现不出优势，但如果我们的软件复杂，有很多层级的依赖，使用 wire 自动生成注入逻辑，无疑更加方便和准确。</p><h5>5. 高级用法</h5><p>wire 还有更多功能，比如 cleanup, bind 等等，请参考官方文档来使用。</p><p>最后，其实多折腾几次，就会使用了，希望本文能对您起到一定程度上的帮助。</p><h2>相关文献</h2><ul><li><a href="https://github.com/google/wire">https://github.com/google/wire</a></li><li><a href="https://go-kratos.dev/docs/getting-started/wire">https://go-kratos.dev/docs/getting-started/wire</a></li><li><a href="https://github.com/go-kratos/kratos-layout">https://github.com/go-kratos/kratos-layout</a></li><li><a href="https://farer.org">https://farer.org</a></li></ul>]]></content>
        <author>
            <name>Windfarer</name>
            <uri>https://github.com/Windfarer</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kratos 学习笔记 - 基于 OpenTelemetry 的链路追踪]]></title>
        <id>go-kratos-opentelemetry-practice</id>
        <link href="https://go-kratos.dev/en/blog/go-kratos-opentelemetry-practice"/>
        <updated>2021-06-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[分布式跟踪（也称为分布式请求跟踪）是一种用于分析和监控应用程序的方法，尤其是使用微服务架构构建的应用程序。分布式跟踪有助于精确定位故障发生的位置以及导致性能差的原因。]]></summary>
        <content type="html"><![CDATA[<h2>链路追踪的前世今生</h2><blockquote><p>分布式跟踪（也称为分布式请求跟踪）是一种用于分析和监控应用程序的方法，尤其是使用微服务架构构建的应用程序。分布式跟踪有助于精确定位故障发生的位置以及导致性能差的原因。   </p><h3>起源</h3><p>链路追踪(Distributed Tracing)　一词最早出现于谷歌发布的论文 <strong>《Dapper, a Large-Scale Distributed Systems Tracing Infrastructure》</strong> 中,这篇论文对于实现链路追踪,对于后来出现的 Jaeger、Zipkin 等开源分布式追踪项目设计理念仍有很深的影响。</p></blockquote><p>微服务架构是一个分布式的架构,会有很多个不同的服务。不同的服务之前相互调用,如果出现了错误由于一个请求经过了 N 个服务。随着业务的增加越来越多的服务之间的调用，如果没有一个工具去记录调用链，解决问题的时候就会像下面图片里小猫咪玩的毛线球一样，毫无头绪，无从下手
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2dd5606765649969819396ba574a741~tplv-k3u1fbpfcp-watermark.image" alt="image.png"/>
所以需要有一个工具能够清楚的了解一个请求经过了哪些服务,顺序是如何,从而能够轻易的定位问题。
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7098634cefe74a3cbacf5e76c343bd81~tplv-k3u1fbpfcp-watermark.image" alt="image.png"/></p><h3>百家争艳</h3><p>从谷歌发布 <strong>Dapper</strong> 后，分布式链路追踪工具越来越多，以下简单列举了一些常用的链路追踪系统</p><ul><li>Skywalking</li><li>阿里 鹰眼</li><li>大众点评 CAT</li><li>Twitter Zipkin</li><li>Naver pinpoint</li><li>Uber Jaeger</li></ul><h3>争锋相对？</h3><p>随着链路追踪工具越来越多，开源领域主要分为两派，一派是以 <strong>CNCF技术委员</strong> 会为主的  <strong>OpenTracing</strong> 的规范，例如 jaeger zipkin 都是遵循了<strong>OpenTracing</strong> 的规范。而另一派则是谷歌作为发起者的 <strong>OpenCensus</strong>，而且谷歌本身还是最早提出链路追踪概念的公司，后期连微软也加入了 <strong>OpenCensus</strong>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3029f1315fe34ec884858d33d41cb1ce~tplv-k3u1fbpfcp-watermark.image" alt="截屏2021-05-29 下午9.56.57.png"/></p><h3>OpenTelemetry 诞生</h3><blockquote><p>OpenTelemetric 是一组 API、SDK、模组和集成，专为创建和管理‎‎遥测数据‎‎（如追踪、指标和日志）而设</p></blockquote><p>微软加入 <strong>OpenCensus</strong> 后，直接打破了之前平衡的局面，间接的导致了 <strong>OpenTelemetry</strong> 的诞生
谷歌和微软下定决心结束江湖之乱，首要的问题是如何整合两个两个社区已有的项目，OpenTelemetry 主要的理念就是，兼容 <strong>OpenCensus</strong> 和 <strong>OpenTracing</strong> ，可以让使用者无需改动或者很小的改动就可以接入 <strong>OpenTelemetry</strong></p><h2>Kratos 的链路追踪实践</h2><blockquote><p>Kratos 一套轻量级 Go 微服务框架，包含大量微服务相关框架及工具。</p></blockquote><h3>tracing 中间件</h3><p>kratos 框架提供的自带中间件中有一个名为 <strong>tracing</strong> 中间件，它基于 <strong>Opentelemetry</strong> 实现了kratos 框架的链路追踪功能，中间件的代码可以从 <strong><a href="https://github.com/go-kratos/kratos/tree/main/middleware/tracing">middleware/tracing</a></strong> 中看到。</p><h4>实现原理</h4><p>kratos 的链路追踪中间件由三个文件组成 <strong>carrie.go</strong>,<strong>tracer.go</strong>,<strong>tracing.go</strong>。client和 server 的实现原理基本相同，本文以 server 实现进行原理解析。</p><ol><li>首先当请求进入时，<strong>tracing</strong> 中间件会被调用,首先调用了 <strong>tracer.go</strong> 中的 <strong>NewTracer</strong> 方法</li></ol><pre><code class="language-go">// Server returns a new server middleware for OpenTelemetry.
func Server(opts ...Option) middleware.Middleware {
        // 调用 tracer.go 中的 NewTracer 传入了一个 SpanKindServer 和配置项
    tracer := NewTracer(trace.SpanKindServer, opts...)
        // ... 省略代码
}
</code></pre><ol start="2"><li><strong>tracer.go</strong> 中的 <strong>NewTracer</strong> 方法被调用后会返回一个 <strong>Tracer</strong>,实现如下</li></ol><pre><code class="language-go">func NewTracer(kind trace.SpanKind, opts ...Option) *Tracer {
    options := options{}
    for _, o := range opts {
        o(&amp;options)
    }
    // 判断是否存在 otel 追踪提供者配置，如果存在则设置
    if options.TracerProvider != nil {
        otel.SetTracerProvider(options.TracerProvider)
    }
    /*
    判断是否存在 Propagators 设置，如果存在设置则覆盖，不存在则设置一个默认的TextMapPropagator
    注意如果没有设置默认的TextMapPropagator,链路信息则无法正确的传递
    */
    if options.Propagators != nil {
        otel.SetTextMapPropagator(options.Propagators)
    } else {    otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(propagation.Baggage{}, propagation.TraceContext{}))
    }


    var name string
    // 判断当前中间件的类型，是 server 还是 client
    if kind == trace.SpanKindServer {
        name = &quot;server&quot;
    } else if kind == trace.SpanKindClient {
        name = &quot;client&quot;
    } else {
        panic(fmt.Sprintf(&quot;unsupported span kind: %v&quot;, kind))
    }
    // 调用 otel包的 Tracer 方法 传入 name 用来创建一个 tracer 实例
    tracer := otel.Tracer(name)
    return &amp;Tracer{tracer: tracer, kind: kind}
}
</code></pre><ol start="3"><li>判断当前请求类型，处理需要采集的数据，并调用 <strong>tracer.go</strong> 中的 <strong>Start</strong> 方法</li></ol><pre><code class="language-go">var (
    component string
    operation string
    carrier   propagation.TextMapCarrier
)
// 判断请求类型
if info, ok := http.FromServerContext(ctx); ok {
    // HTTP
    component = &quot;HTTP&quot;
    // 取出请求的地址
    operation = info.Request.RequestURI
    // 调用 otel/propagation包中的 HeaderCarrier，会处理 http.Header 以用来满足TextMapCarrier interface
    // TextMapCarrier 是一个文本映射载体，用于承载信息
    carrier = propagation.HeaderCarrier(info.Request.Header)
    // otel.GetTextMapPropagator().Extract() 方法用于将文本映射载体，读取到上下文中
    ctx = otel.GetTextMapPropagator().Extract(ctx, propagation.HeaderCarrier(info.Request.Header))
} else if info, ok := grpc.FromServerContext(ctx); ok {
    // Grpc
    component = &quot;gRPC&quot;
    operation = info.FullMethod
    //
    // 调用 grpc/metadata包中metadata.FromIncomingContext(ctx)传入 ctx，转换 grpc 的元数据
    if md, ok := metadata.FromIncomingContext(ctx); ok {
        // 调用carrier.go 中的 MetadataCarrier 将 MD 转换 成文本映射载体
        carrier = MetadataCarrier(md)
    }
}
// 调用 tracer.Start 方法
ctx, span := tracer.Start(ctx, component, operation, carrier)
// ... 省略代码
}
</code></pre><ol start="4"><li>调用 <strong>tracing.go</strong> 中的 <strong>Start</strong> 方法</li></ol><pre><code class="language-go">func (t *Tracer) Start(ctx context.Context, component string, operation string, carrier propagation.TextMapCarrier) (context.Context, trace.Span) {
    // 判断当前中间件如果是 server则将 carrier 注入到上下文中
    if t.kind == trace.SpanKindServer {
        ctx = otel.GetTextMapPropagator().Extract(ctx, carrier)
    }
    // 调用otel/tracer 包中的 start 方法，用来创建一个 span
    ctx, span := t.tracer.Start(ctx,
        // tracing.go 中声明的请求路由作为 spanName
        operation,
        // 设置 span 的属性，设置了一个 component，component的值为请求类型
        trace.WithAttributes(attribute.String(&quot;component&quot;, component)),
        // 设置 span种类
        trace.WithSpanKind(t.kind),
    )
    // 判断如果当前中间件是 client 则将 carrier 注入到请求里面
    if t.kind == trace.SpanKindClient {
        otel.GetTextMapPropagator().Inject(ctx, carrier)
    }
    return ctx, span
}
</code></pre><ol start="5"><li><strong>defer</strong> 声明了一个闭包方法</li></ol><pre><code class="language-golang">// 这个地方要注意，需要使用闭包，因为 defer 的参数是实时计算的如果异常发生，err 会一直为 nil
// https://github.com/go-kratos/kratos/issues/927
defer func() { tracer.End(ctx, span, err) }()
</code></pre><ol start="6"><li>中间件继续执行</li></ol><pre><code class="language-go">// tracing.go 69行
reply, err = handler(ctx, req)
</code></pre><ol start="7"><li>中间件调用结束 <strong>defer</strong> 中的闭包被调用后执行了 <strong>tracer.go</strong> 中的 <strong>End</strong> 方法</li></ol><pre><code class="language-go">func (t *Tracer) End(ctx context.Context, span trace.Span, err error) {
    // 判断是否有异常发生，如果有则设置一些异常信息
    if err != nil {
        // 记录异常
        span.RecordError(err)
        // 设置span 属性
        span.SetAttributes(
            // 设置事件为异常
            attribute.String(&quot;event&quot;, &quot;error&quot;),
            // 设置 message 为 err.Error().
            attribute.String(&quot;message&quot;, err.Error()),
        )
        //设置了 span 的状态
        span.SetStatus(codes.Error, err.Error())
    } else {
        // 如果没有发生异常，span 状态则为 ok
        span.SetStatus(codes.Ok, &quot;OK&quot;)
    }
    // 中止 span
    span.End()
}
</code></pre><h4>如何使用</h4><p>tracing 中间件的使用示例可以从  <a href="https://github.com/go-kratos/kratos/tree/main/examples/traces">kratos/examples/traces</a> ,该示例简单的实现了跨服务间的链路追踪,以下代码片段包含部分示例代码。</p><pre><code class="language-go">// https://github.com/go-kratos/kratos/blob/7f835db398c9d0332e69b81bad4c652b4b45ae2e/examples/traces/app/message/main.go#L38
// 首先调用otel 库方法，得到一个 TracerProvider
func tracerProvider(url string) (*tracesdk.TracerProvider, error) {
    // examples/traces 中使用的是 jaeger，其他方式可以查看 opentelemetry 官方示例
    exp, err := jaeger.NewRawExporter(jaeger.WithCollectorEndpoint(jaeger.WithEndpoint(url)))
    if err != nil {
        return nil, err
    }
    tp := tracesdk.NewTracerProvider(
        tracesdk.WithSampler(tracesdk.AlwaysSample()),
        // 设置 Batcher，注册jaeger导出程序
        tracesdk.WithBatcher(exp),
        // 记录一些默认信息
        tracesdk.WithResource(resource.NewWithAttributes(
            semconv.ServiceNameKey.String(pb.User_ServiceDesc.ServiceName),
            attribute.String(&quot;environment&quot;, &quot;development&quot;),
            attribute.Int64(&quot;ID&quot;, 1),
        )),
    )
    return tp, nil
}
</code></pre><h4>在 grpc/server 中使用</h4><pre><code class="language-go">// https://github.com/go-kratos/kratos/blob/main/examples/traces/app/message/main.go
grpcSrv := grpc.NewServer(
    grpc.Address(&quot;:9000&quot;),
    grpc.Middleware(
        // Configuring tracing Middleware
        tracing.Server(
            tracing.WithTracerProvider(tp),
        ),
    ),
)
</code></pre><h4>在 grpc/client 中使用</h4><pre><code class="language-go">// https://github.com/go-kratos/kratos/blob/149fc0195eb62ee1fbc2728adb92e1bcd1a12c4e/examples/traces/app/user/main.go#L63
conn, err := grpc.DialInsecure(ctx,
    grpc.WithEndpoint(&quot;127.0.0.1:9000&quot;),
    grpc.WithMiddleware(
        tracing.Client(
            tracing.WithTracerProvider(s.tracer),
            tracing.WithPropagators(
                propagation.NewCompositeTextMapPropagator(propagation.Baggage{}, propagation.TraceContext{}),
            ),
        )
    ),
    grpc.WithTimeout(2*time.Second),
)
</code></pre><h4>在 http/server 中使用</h4><pre><code class="language-go">// https://github.com/go-kratos/kratos/blob/main/examples/traces/app/user/main.go
httpSrv := http.NewServer(http.Address(&quot;:8000&quot;))
httpSrv.HandlePrefix(&quot;/&quot;, pb.NewUserHandler(s,
    http.Middleware(
        // Configuring tracing middleware
        tracing.Server(
            tracing.WithTracerProvider(tp),
            tracing.WithPropagators(
                propagation.NewCompositeTextMapPropagator(propagation.Baggage{}, propagation.TraceContext{}),
            ),
        ),
    ),
)
</code></pre><h4>在 http/client 中使用</h4><pre><code class="language-go">http.NewClient(ctx, http.WithMiddleware(
    tracing.Client(
        tracing.WithTracerProvider(s.tracer),
    ),
))
</code></pre><h4>如何实现一个其他场景的 tracing</h4><p>我们可以借鉴 <strong>kratos</strong> 的 <strong>tracing</strong> 中间件的代码来实现例如数据库的 <strong>tracing</strong>，如下面的代码片段，作者借鉴了<strong>tracing</strong> 中间件，实现了 <strong>qmgo</strong> 库操作 <strong>MongoDB</strong> 数据库的 <strong>tracing</strong>。</p><pre><code class="language-go">func mongoTracer(ctx context.Context,tp trace.TracerProvider, command interface{}) {
    var (
        commandName string
        failure     string
        nanos       int64
        reply       bson.Raw
        queryId     int64
        eventName   string
    )
    otel.SetTracerProvider(tp)
    reply = bson.Raw{}
    switch value := command.(type) {
    case *event.CommandStartedEvent:
        commandName = value.CommandName
        reply = value.Command
        queryId = value.RequestID
        eventName = &quot;CommandStartedEvent&quot;
    case *event.CommandSucceededEvent:
        commandName = value.CommandName
        nanos = value.DurationNanos
        queryId = value.RequestID
        eventName = &quot;CommandSucceededEvent&quot;
    case *event.CommandFailedEvent:
        commandName = value.CommandName
        failure = value.Failure
        nanos = value.DurationNanos
        queryId = value.RequestID
        eventName = &quot;CommandFailedEvent&quot;
    }
    duration, _ := time.ParseDuration(strconv.FormatInt(nanos, 10) + &quot;ns&quot;)
    tracer := otel.Tracer(&quot;mongodb&quot;)
    kind := trace.SpanKindServer
    ctx, span := tracer.Start(ctx,
        commandName,
        trace.WithAttributes(
            attribute.String(&quot;event&quot;, eventName),
            attribute.String(&quot;command&quot;, commandName),
            attribute.String(&quot;query&quot;, reply.String()),
            attribute.Int64(&quot;queryId&quot;, queryId),
            attribute.String(&quot;ms&quot;, duration.String()),
        ),
        trace.WithSpanKind(kind),
    )
    if failure != &quot;&quot; {
        span.RecordError(errors.New(failure))
    }
    span.End()
}
</code></pre><h2>参考文献</h2><ul><li><a href="https://www.researchgate.net/publication/239595848_Dapper_a_Large-Scale_Distributed_Systems_Tracing_Infrastructure">谷歌论文《Dapper, a Large-Scale Distributed Systems Tracing Infrastructure》</a></li><li><a href="https://opentelemetry.io/">OpenTelemetry 官网</a></li><li><a href="https://static.sched.com/hosted_files/kccncosschn19chi/03/OpenTelemetry_%20Overview%20%26%20Backwards%20Compatibility%20of%20OpenTracing%20%2B%20OpenCensus%20-%20Steve%20Flanders%2C%20Omnition.pdf">KubeCon2019 OpenTelemetry分享</a></li><li><a href="https://go-kratos.dev/docs/getting-started/start">Kratos 框架</a></li><li><a href="https://github.com/go-kratos/kratos/tree/main/examples/traces">traces 示例</a></li></ul>]]></content>
        <author>
            <name>shenqidebaozi</name>
            <uri>https://github.com/shenqidebaozi</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kratos 学习笔记 - 通过 layout 简单分析应用是如何跑起来的]]></title>
        <id>go-layout-operation-process</id>
        <link href="https://go-kratos.dev/en/blog/go-layout-operation-process"/>
        <updated>2021-06-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[通过 layout 简单分析应用是如何跑起来的]]></summary>
        <content type="html"><![CDATA[<h2>0X01 通过 layout 探索 kratos 运行原理（kratos v2.0.0-beta4）</h2><h3>创建项目</h3><p>首先需要安装好对应的依赖环境，以及工具：</p><ul><li>go</li><li>protoc</li><li>protoc-gen-go</li></ul><pre><code class="language-bash">  # 创建项目模板
kratos new helloworld

cd helloworld
# 拉取项目依赖
go mod download
# 生成proto模板
kratos proto add api/helloworld/helloworld.proto
# 生成proto源码
kratos proto client api/helloworld/helloworld.proto
# 生成server模板
kratos proto server api/helloworld/helloworld.proto -t internal/service
</code></pre><p>执行命令后,会在当前目录下生成一个 service 工程,工程骨架如下,具体的工程骨架说明可以访问 <a href="https://go-kratos.dev/docs/intro/layout">layout</a>
<img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2919854308c04803bef327b4f67f31f8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"/></p><h3>运行项目</h3><pre><code class="language-bash"># 生成所有proto源码、wire等等
go generate ./...

# 编译成可执行文件
go build -o ./bin/ ./...

# 运行项目
./bin/helloworld -conf ./configs
</code></pre><p>看到如下输出则证明项目启动正常</p><pre><code class="language-shell">level=INFO module=app service_id=7114ad8a-b3bf-11eb-a1b9-f0189850d2cb service_name=  version=
level=INFO module=transport/grpc msg=[gRPC] server listening on: [::]:9000
level=INFO module=transport/http msg=[HTTP] server listening on: [::]:8000 
</code></pre><p>测试接口</p><pre><code class="language-shell">curl &#x27;http://127.0.0.1:8000/helloworld/krtaos&#x27;

输出：
{
  &quot;message&quot;: &quot;Hello kratos&quot;
}
</code></pre><h3>应用是如何跑起来的?</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f714f793562459ea2a136aa4399494d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"/>
通过上面的图例👆,我们可以直观观察到应用的调用链,简化来说如下图流程所示👇</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87d64f1a4f0e41afbb49bed6e003999c~tplv-k3u1fbpfcp-watermark.image" alt="未命名文件(2).png"/></p><h4>1. 注入依赖并调用 newApp() 方法</h4><pre><code class="language-go">// helloword/cmd/main.go
func main() {
    flag.Parse()
    logger := log.NewStdLogger(os.Stdout)

    // 调用 go-kratos/kratos/v2/config,创建 config 实例,并指定了来源和配置解析方法
    c := config.New(
    config.WithSource(
        file.NewSource(flagconf),
    ),
    config.WithDecoder(func(kv *config.KeyValue, v map[string]interface{}) error {
        return yaml.Unmarshal(kv.Value, v)
    }),
    )
    if err := c.Load(); err != nil {
        panic(err)
    }

    // 将配置扫描到,通过 proto 声明的 conf struct 上
    var bc conf.Bootstrap
    if err := c.Scan(&amp;bc); err != nil {
        panic(err)
    }

    // 通过 wire 将依赖注入,并调用 newApp 方法
    app, cleanup, err := initApp(bc.Server, bc.Data, logger)
    if err != nil {
        panic(err)
    }
    // 省略代码...
}
</code></pre><h4>2. 创建 kratos 实例</h4><p>项目 main.go 的 <strong>newApp()</strong> 方法中,调用了 <strong>go-kratos/kratos/v2/app.go</strong> 中的 <strong>kratos.New()</strong> 方法</p><pre><code class="language-go">// helloword/cmd/main.go
func newApp(logger log.Logger, hs *http.Server, gs *grpc.Server) *kratos.App {
    return kratos.New(
        // 配置应用   
        kratos.Name(Name),
        kratos.Version(Version),
        kratos.Metadata(map[string]string{}),
        kratos.Logger(logger),
        // kratos.Server() 传入的 http/grpc 服务会通过 buildInstance() 转换成registry.ServiceInstance struct*
        kratos.Server(
            hs,
            gs,
        ),
    )
}
</code></pre><p>该方法会返回一个 <strong>App struct</strong>,包含 <strong>Run()</strong> 和 <strong>Stop()</strong> 方法</p><pre><code class="language-go">// go-kratos/kratos/v2/app.go
type App struct {
    opts     options //配置
    ctx      context.Context // 上下文
    cancel   func() // context 的取消方法
    instance *registry.ServiceInstance //通过 kratos.Server()声明的实例,并通过 buildInstance() 转换后的 *registry.ServiceInstance struct
    log      *log.Helper // 日志
}

// Run executes all OnStart hooks registered with the application&#x27;s Lifecycle.
func (a *App) Run() error {
    // 省略代码...
}

// Stop gracefully stops the application.
func (a *App) Stop() error {
    // 省略代码...
}
</code></pre><h4>3. 调用 Run() 方法</h4><p>项目在 main 方法中调用了 <strong>kratos.App struct</strong> 的 <strong>Run()</strong> 方法.</p><pre><code class="language-go">// helloword/cmd/main.go
// 省略代码...
// 启动 Kratos
if err := app.Run(); err != nil {
    panic(err)
}
</code></pre><p><strong>Run()</strong> 方法的实现细节</p><pre><code class="language-go">// go-kratos/kratos/v2/app.go
func (a *App) Run() error {
    a.log.Infow(
        &quot;service_id&quot;, a.opts.id,
        &quot;service_name&quot;, a.opts.name,
        &quot;version&quot;, a.opts.version,
    )
    g, ctx := errgroup.WithContext(a.ctx)
        // 遍历通过 kratos.Server() 声明的服务实例
    for _, srv := range a.opts.servers {
        srv := srv
                // 执行两个goroutine, 用于处理服务启动和退出
        g.Go(func() error {
            &lt;-ctx.Done() // 阻塞,等待调用 cancel 方法
            return srv.Stop() // 协程退出后,调用实例的停止方法
        })
        g.Go(func() error {
            return srv.Start() // 调用实例的运行方法
        })
    }
        // 判断是否调用 kratos.Registrar() 配置了注册发现中心
    if a.opts.registrar != nil {
        // 将实例注册到注册中心
        if err := a.opts.registrar.Register(a.opts.ctx, a.instance); err != nil 
            return err
        }
    }
        // 监听进程退出信号
    c := make(chan os.Signal, 1)
    signal.Notify(c, a.opts.sigs...)
        
        // 处理进程退出和 context 退出
    g.Go(func() error {
        for {
            select {
            case &lt;-ctx.Done():
                return ctx.Err()
            case &lt;-c:
                        // 调用 kratos.App 的停止方法
                a.Stop()
            }
        }
    })
    if err := g.Wait(); err != nil &amp;&amp; !errors.Is(err, context.Canceled) {
        return err
    }
    return nil
}
</code></pre><h4>4. 应用退出</h4><p>Kratos 实例在启动时,监听了系统的进程退出信号,当收到退出信号时,kratos 会调用 <strong>App struct</strong> 的 <strong>Stop()</strong> 方法</p><pre><code class="language-go">// go-kratos/kratos/v2/app.go
func (a *App) Stop() error {
    // 判断是否有注册中心配置
    if a.opts.registrar != nil {
        // 在注册中心中将实例注销
        if err := a.opts.registrar.Deregister(a.opts.ctx, a.instance); err != nil {
            return err
        }
    }
    // 控制 goroutine 的退出,当调用 a.cancel()时,Run()方法中 监听的 &lt;-ctx.Done() 收到消息后,没有阻塞后,方法会调用 server 的 Stop()方法,停止服务
    if a.cancel != nil {
        a.cancel()
    }
    return nil
}
</code></pre>]]></content>
        <author>
            <name>shenqidebaozi</name>
            <uri>https://github.com/shenqidebaozi</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Go工程化 - Project Layout 最佳实践]]></title>
        <id>go-project-layout</id>
        <link href="https://go-kratos.dev/en/blog/go-project-layout"/>
        <updated>2021-03-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Go 项目工程化/基础库，在项目不同角度中的设计理念，Go 是一个面向包名设计的语言，可以通过各个包名进行组织 Go 的项目布局]]></summary>
        <content type="html"><![CDATA[<h2>介绍</h2><p>这篇文章主要讲 <strong>Go 项目工程化</strong> 上的一些思考，以及 <strong>Kratos</strong> 在项目不同角度中的设计理念。</p><p>Go 是一个面向包名设计的语言，可以通过各个包名进行组织 Go 的项目布局，而大家遵循规范设计准则，可以很好地改善团队成员之间的沟通。</p><h2>项目布局</h2><p>每个公司都应当为不同的微服务建立一个统一的 Kit 工具包项目（基础库/框架）和 Application 项目。
基础库 Kit 为独立项目，公司级建议只有一个，按照功能目录来拆分会带来不少的管理工作，因此建议合并整合。</p><blockquote><p>by Package Oriented Design
“To this end, the Kit project is not allowed to have a vendor folder. If any of packages are dependent on 3rd party packages, they must always build against the latest version of those dependences.”</p></blockquote><h3>Kit 基础库</h3><p>将 Kit 项目作为公司的标准库，因此应该只有一个。并且 Kit 基础库也应该具备以下这些特点：</p><ul><li>简单：不过度设计，代码平实简单；</li><li>通用：通用业务开发所需要的基础库的功能；</li><li>高效：提高业务迭代的效率；</li><li>稳定：基础库可测试性高，覆盖率高，有线上实践安全可靠；</li><li>健壮：通过良好的基础库设计，减少错用；</li><li>高性能：性能高，但不特定为了性能做 hack 优化，引入 unsafe ；</li><li>扩展性：良好的接口设计，来扩展实现，或者通过新增基础库目录来扩展功能；</li><li>容错性：为失败设计，大量引入对 SRE 的理解，鲁棒性高；</li><li>工具链：包含大量工具链，比如辅助代码生成，lint 工具等等；</li></ul><p>以 Kratos 为例子，一个典型的 Kit 基础库 可能看起来像这样：</p><pre><code>github.com/go-kratos/kratos
├── cmd
├── docs
├── internal
├── examples
├── api
├── errors
├── config
├── encoding
├── log
├── metrics
├── metadata
├── middleware
├── transport
├── registry
├── third_party
├── app.go
├── options.go
├── go.mod
├── go.sum
</code></pre><blockquote><p>注意：为了保证 Kit 基础库的可移植性，尽可能进行接口抽象，并且 go.mod 依赖第三方库也尽可能简单，然后再通过 plugins 进行扩展基础库，以满足不同的业务需求定制化。</p></blockquote><h3>Application 应用项目</h3><p>如果你尝试学习 Go，或者你正在为自己建立一个 PoC 或一个玩具项目，这个项目布局是没啥必要的。从一些非常简单的事情开始（一个 main.go 文件绰绰有余）。当有更多的人参与这个项目时，你将需要更多的结构，包括需要一个 Toolkit 来方便生成项目的模板，尽可能大家统一的工程目录布局。</p><img src="/images/ddd.png" alt="kratos ddd" width="500px"/><p>例如，通过 Kratos 工具生成一个 Go工程化项目 模板：</p><pre><code># 创建项目模板
kratos new helloworld

cd helloworld
# 拉取项目依赖
go mod download
# 生成proto模板
kratos proto add api/helloworld/helloworld.proto
# 生成client源码
kratos proto client api/helloworld/helloworld.proto
# 生成server模板
kratos proto server api/helloworld/helloworld.proto -t internal/service
</code></pre><p>在 Kratos 中，一个典型的 Go 项目布局 可能看起来像这样：</p><pre><code>application
|____api
| |____helloworld
| | |____v1
| | |____errors
|____cmd
| |____helloworld
|____configs
|____internal
| |____conf
| |____data
| |____biz
| |____service
| |____server
|____test
|____pkg
|____go.mod
|____go.sum
|____LICENSE
|____README.md
</code></pre><h3>应用类型</h3><p>微服务中的 app 服务类型主要分为4类：interface、service、job、admin，应用 cmd 目录负责程序的：启动、关闭、配置初始化等。</p><ul><li>interface: 对外的 BFF 服务，接受来自用户的请求，比如暴露了 HTTP/gRPC 接口。</li><li>service: 对内的微服务，仅接受来自内部其他服务或者网关的请求，比如暴露了gRPC 接口只对内服务。</li><li>admin：区别于 service，更多是面向运营测的服务，通常数据权限更高，隔离带来更好的代码级别安全。</li><li>job: 流式任务处理的服务，上游一般依赖 message broker。</li><li>task: 定时任务，类似 cronjob，部署到 task 托管平台中。</li></ul><h2>应用目录</h2><h3>/cmd</h3><p>本项目的主干。
每个应用程序的目录名应该与你想要的可执行文件的名称相匹配（例如，<code>/cmd/myapp</code>）。
不要在这个目录中放置太多代码。如果你认为代码可以导入并在其他项目中使用，那么它应该位于 <code>/pkg</code> 目录中。如果代码不是可重用的，或者你不希望其他人重用它，请将该代码放到 <code>/internal</code> 目录中。</p><h3>/internal</h3><p>私有应用程序和库代码。这是你不希望其他人在其应用程序或库中导入代码。请注意，这个布局模式是由 Go 编译器本身执行的。有关更多细节，请参阅 Go 1.4 release notes。注意，你并不局限于顶级 <code>internal</code> 目录。在项目树的任何级别上都可以有多个内部目录。
你可以选择向 <code>internal</code> 包中添加一些额外的结构，以分隔共享和非共享的内部代码。这不是必需的(特别是对于较小的项目)，但是最好有有可视化的线索来显示预期的包的用途。你的实际应用程序代码可以放在 <code>/internal/app</code> 目录下（例如 <code>/internal/app/myapp</code>），这些应用程序共享的代码可以放在 <code>/internal/pkg</code> 目录下（例如 /internal/pkg/myprivlib）。
因为我们习惯把相关的服务，比如账号服务，内部有 rpc、job、admin 等，相关的服务整合一起后，需要区分 app。单一的服务，可以去掉 <code>/internal/myapp</code>。</p><h3>/pkg</h3><p>外部应用程序可以使用的库代码（例如 <code>/pkg/mypubliclib</code>）。其他项目会导入这些库，所以在这里放东西之前要三思:-)注意，<code>internal</code> 目录是确保私有包不可导入的更好方法，因为它是由 Go 强制执行的。<code>/pkg</code> 目录仍然是一种很好的方式，可以显式地表示该目录中的代码对于其他人来说是安全使用的好方法。</p><blockquote><p>/pkg 目录内，可以参考 go 标准库的组织方式，按照功能分类。/internla/pkg 一般用于项目内的 跨多个应用的公共共享代码，但其作用域仅在单个项目工程内。  </p></blockquote><p>由 Travis Jeffery  撰写的 I&#x27;ll take pkg over internal 博客文章提供了 <code>pkg</code> 和 <code>internal</code> 目录的一个很好的概述，以及什么时候使用它们是有意义的。
当根目录包含大量非 Go 组件和目录时，这也是一种将 Go 代码分组到一个位置的方法，这使得运行各种 Go 工具变得更加容易组织。 </p><h2>服务应用目录</h2><h3>/api</h3><p>​    API 协议定义目录，services.proto protobuf 文件，以及生成的 go 文件。我们通常把 api 文档直接在 proto 文件中描述。</p><h3>/configs</h3><p>​    配置文件模板或默认配置。</p><h3>/test</h3><p>​    额外的外部测试应用程序和测试数据。你可以随时根据需求构造 /test 目录。对于较大的项目，有一个数据子目录是有意义的。例如，你可以使用 /test/data 或 /test/testdata (如果你需要忽略目录中的内容)。请注意，Go 还会忽略以 “.” 或 “_” 开头的目录或文件，因此在如何命名测试数据目录方面有更大的灵活性。</p><h2>服务内部目录</h2><p>Application 目录下有 api、cmd、configs、internal、pkg 目录，目录里一般还会放置 README、CHANGELOG、OWNERS。</p><p>internal 是为了避免有同业务下有人跨目录引用了内部的 data、biz、service、server 等内部 struct。</p><h3>data</h3><p>业务数据访问，包含 cache、db 等封装，实现了 biz 的 repo 接口。我们可能会把 data 与 dao 混淆在一起，data 偏重业务的含义，它所要做的是将领域对象重新拿出来，我们去掉了 DDD 的 infra层。</p><h3>biz</h3><p>业务逻辑的组装层，类似 DDD 的 domain 层，data 类似 DDD 的 repo，repo 接口在这里定义，使用依赖倒置的原则。</p><h3>service</h3><p>实现了 api 定义的服务层，类似 DDD 的 application 层，处理 DTO 到 biz 领域实体的转换（DTO -&gt; DO），同时协同各类 biz 交互，但是不应处理复杂逻辑。</p><h3>server</h3><p>为http和grpc实例的创建和配置，以及注册对应的 service 。</p><h2>不建议的目录</h2><h3><del>src/</del></h3><p>  src 目录在 java 开发语言的项目中是一个常用的模式，但是在 go 开发项目中，尽量不要使用 src 目录。</p><h3><del>model/</del></h3><p> 在其他语言开发中一个非常通用的模块叫 model，把所有类型都放在 model 里。但是在 go 里不建议的，因为 go 的包设计是根据功能职责划分的。比如一个 User 模型，应该声明在他被用的功能模块里。</p><h3><del>xxs/</del></h3><p>  带复数的目录或包。虽然 go 源码中有 strings 包，但更多都是用单数形式。</p><h2>总结</h2><p>在实际 go 项目开发中，一定要灵活运用，当然也可以完全不按照这样架构分层、包设计的规则，一切以项目的大小、业务的复杂度、个人专业技能认知的广度和深度、时间的紧迫度为准。</p><p>并且，一定要按实际情况，选择合适自己团队的 Kit 基础库，进行充分的调研以及是否可满足插件定制化，需要维护好属于团队的 Kit 基础库 和 代码规范 ，带动开发者进行积极参与贡献。</p><p>如果大家有更好的架构设计理念，欢迎到 go-kratos 社区进行探讨，希望这篇文章对您有帮助~</p><h2>参考文献</h2><ul><li><a href="https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html">Package Oriented Design</a></li><li><a href="https://docs.microsoft.com/en-us/previous-versions/msp-n-p/ee658109(v=pandp.10)">Layered Application Guidelines</a></li><li><a href="https://github.com/golang-standards/project-layout">Standard Go Project Layout</a></li><li><a href="https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md">Go 面向包的设计和架构分层</a></li><li><a href="https://u.geekbang.org/subject/go">Go 进阶训练营 - 极客时间</a></li></ul>]]></content>
        <author>
            <name>Tony</name>
            <uri>https://github.com/tonybase</uri>
        </author>
    </entry>
</feed>